import math
from collections import deque

"""
План кода


   1. Формула для расчета вероятности
  


  Формула рассчитывает вероятность утверждений
  claimk - утвержденное игроком количество кубиков
  claimval - утвержденное игроком значение кубиков
  knowndice - наши кубики (известны)
  totaldice - общее количество чужих-неизвестных кубиков
  maputo - статус мапуто. Изначально мы его объявляем False, потому что так в большинстве случаев
  """
def formula(claimk, claimval, knowndice, totaldice, maputo=False): # считаем сколько у нас уже есть нужных значений среди наших кубиков (включая джокеры - единицы)
  sovpav = knowndice.count(claimval) # считает количество названных игроком значений среди наших кубиков
  if not maputo and claimval != 1:
      sovpav += knowndice.count(1) # добавляем к посчитанному единицы-джокеры (если не мапуто)
  ostatok = claimk - sovpav # остаток - сколько нужно кубиков с таким значением среди не наших (см. для обоснования файл с формулами, стр. 3 под графиком)
  if ostatok <= 0:
      return 1.0 # если среди наших уже набралось достаточно, то вероятность 100%
  res = 0.0 # базовая вероятность, к которой мы уже плюсуем - иначе получается кривой return. лучше объявить это до цикла
  n = totaldice
  # считаем вероятность по формуле (см. файл с формулами)
  for i in range(ostatok, n + 1): # нам же подходит не только заявленное количество, но и большее - см. файл
      combs = math.comb(n, i)# встроенная функция из библиотеки math про сочетания, работает на версиях 3.8 и выше!
      if maputo:
          # формула для статуса мапуто (без джокеров-единиц)
          itog = combs * (5 ** (n - i)) / (6 ** n)
      else:
          # базовая формула (с джокерами-единицами)
          itog = combs * (4 ** (n - i)) * (2 ** i) / (6 ** n)
      res += itog
  return res
"""
   2. Создание классов
"""
class Player:
"""
Функции про игрока:
   3. Присвоение статусов игроку в начале игры
"""
def __init__(self, name: str): 
       self.name = name #имя - строкой
       self.dice = 5  #у каждого игрока в начале 5 кубиков, int
       self.hand = []  #значения кубиков игрока которые потом  введутся (пустой список, потом будем обновлять через split)
       self.status = "нейтральный"  #статус - по дефолту нейтральный, или мапуто (1 кубик)/проигравший
"""
   4. Обновление статуса игрока
"""
def update_status(self):  # dice и status берем из предыдущей моей штуки, а потом будем обновлять уже в коде самой игры
   if self.dice == 0:  # потом в коде пропишем, что кто с 0,тот ход скипается
       self.status = "проигравший"
   elif self.dice == 1:
       self.status = "мапуто"
   else:  # 2+ кубика
       self.status = "нейтральный"
"""
   5. Введение результата броска игрока
"""
def brosok(self, manual: bool = False):  # функция осуществления бросков
   if manual:  # наш вводим вручную
       while True:
           print("Введите значения своих кубиков (от 1 до 6) через пробел: ")
           values = input().strip().split()  # вводим наши значения через пробел. На всякий случай делаем strip от всего лишнего
           try:  # конструкция try-except - чтобы исключить варианты, когда введено что-то не то
               nums = list(map(int, values))  # закидываем в список
               if len(nums) != self.dice:  # проверка, чтобы количество введенных нами значений совпадало с текущим колвом кубиков
                   print(f"Ошибка: должно быть ровно {self.dice} кубиков!")
                   continue
               if not all(1 <= val <= 6 for val in nums):  # проверка, что все введенные значения в диапазоне 1-6 (кубик-шестигранник)
                   print("Ошибка: значения должны быть от 1 до 6!")
                   continue
               self.hand = nums  # закидываем наш проверенный и правильный список в характеристики класса
               break
           except ValueError:  # вторая часть конструкции try-except. ValueError - проверка на неподдерживаемые значения
               print("Ошибка: вводите только числа!")
   else:  # броски остальных - неизвестны, поэтому оставляем пустыми
       self.hand = []
class Perudo: 
"""
Функции про раунды:
   6. Определение роли игрока в раунде

"""
   def __init__(self, player_names, username):
      self.players = deque([Player(name) for name in player_names]) # deque - двусторонняя очередь, короче, улучшенный список как раз для наших целей. Для него я импортировала модуль в начале.
      self.username = username # username и player_names мы возьмем в конце, в стартовике кода
      self.roundnumb = 0 # ну и объявляшка номера раунда по порядку, когда игра не запущена - нулевой раунд
"""
   7. Определение количества активных игроков
"""
   def get_active_players(self):
          # возвращаем список игроков, у которых еще есть кубики
          return [p for p in self.players if p.dice > 0]
"""
   8. Установление очередности игроков
"""
   def first_player(self, name: str):
          # устанавливаем первого игрока в раунде
          while self.players[0].name != name:
              self.players.rotate(-1)
"""
   9. Проверка наличия нашего игрока в игровом процессе
"""
      def get_user(self):
       # возвращаем объект нашего игрока
       for p in self.players:
           if p.name == self.username:
               return p
       return None
"""
   10. Начало нового раунда (+ мб вывод текущего положения)
"""
def next_round(self): #начинаем раунды
   self.roundnumb += 1 #номер раунда увеличивается + выводим красивенько
   print('--- Раунд ' + str(self.roundnumb) + " ---")
   print("Текущее состояние игроков:")
   for p in self.players: #выводим
       print(p.name + ' : ' + str(p.dice) + " кубиков (" + p.status + ")")


   #производим бросок кубиков по вышенаписанной функции
   for p in self.get_active_players():
       if p.name == self.username:
           p.brosok(manual=True)  #если игрок мы, то вводим сами
       else:
           p.brosok(manual=False)  #если игрок - не мы, то автоматом (пустые)
"""

   11. Если (9) выполняется, то просит утверждение через (5)
"""
   def statement(self, name: str): #вводим стейтементы других игроков
   print('Введите утверждение игрока '+ name + '(например: 6 2) или "Конец": ')
   entry = input()
   if entry == "Конец":
       return "end", None, None #я пока обозначу то, что возвращается вот так - end и claim (в функции запуска это будут флаги-маркеры), может, потом еще поменяю
   try: #конструкция try-except, как до этого у нас была в броске
       k, val = map(int, entry.strip().split()) #вводим наши 6 2 (шесть двоек), k - количество, val - значение-номинал
       return "claim", k, val
   except:
       print("Ошибка формата. Попробуйте снова.") #если вводят что-то левое
       return self.statement(name) #рекурсируем, т.е. возвращаем в начало и просим все ввести заново, если ввели что-то левое до этого
  
"""
   12. Ввод итогов раунда - победа/проигрыш и обновление статуса через (4) + общего кол-ва кубиков
   13. Проверка на победу во всей игре и возвращение итога, при победе
   14. Общая функция процесса игры, в которую мы кладем все предыдущее


   15. Начало игры
"""

