import math


"""
План кода


   1. Формула для расчета вероятности
  


  Формула рассчитывает вероятность утверждений
  claimk - утвержденное игроком количество кубиков
  claimval - утвержденное игроком значение кубиков
  knowndice - наши кубики (известны)
  totaldice - общее количество чужих-неизвестных кубиков
  maputo - статус мапуто. Изначально мы его объявляем False, потому что так в большинстве случаев
  """
def formula(claimk, claimval, knowndice, totaldice, maputo=False): # считаем сколько у нас уже есть нужных значений среди наших кубиков (включая джокеры - единицы)
  sovpav = knowndice.count(claimval) # считает количество названных игроком значений среди наших кубиков
  if not maputo and claimval != 1:
      sovpav += knowndice.count(1) # добавляем к посчитанному единицы-джокеры (если не мапуто)
  ostatok = claimk - sovpav # остаток - сколько нужно кубиков с таким значением среди не наших (см. для обоснования файл с формулами, стр. 3 под графиком)
  if ostatok <= 0:
      return 1.0 # если среди наших уже набралось достаточно, то вероятность 100%
  res = 0.0 # базовая вероятность, к которой мы уже плюсуем - иначе получается кривой return. лучше объявить это до цикла
  n = totaldice
  # считаем вероятность по формуле (см. файл с формулами)
  for i in range(ostatok, n + 1): # нам же подходит не только заявленное количество, но и большее - см. файл
      combs = math.comb(n, i)# встроенная функция из библиотеки math про сочетания, работает на версиях 3.8 и выше!
      if maputo:
          # формула для статуса мапуто (без джокеров-единиц)
          itog = combs * (5 ** (n - i)) / (6 ** n)
      else:
          # базовая формула (с джокерами-единицами)
          itog = combs * (4 ** (n - i)) * (2 ** i) / (6 ** n)
      res += itog
  return res
"""
   2. Создание классов
"""
class Player:
"""
Функции про игрока:
   3. Присвоение статусов игроку в начале игры
"""
def __init__(self, name: str): 
       self.name = name #имя - строкой
       self.dice = 5  #у каждого игрока в начале 5 кубиков, int
       self.hand = []  #значения кубиков игрока которые потом  введутся (пустой список, потом будем обновлять через split)
       self.status = "нейтральный"  #статус - по дефолту нейтральный, или мапуто (1 кубик)/проигравший
"""
   4. Обновление статуса игрока
"""
def update_status(self):  # dice и status берем из предыдущей моей штуки, а потом будем обновлять уже в коде самой игры
   if self.dice == 0:  # потом в коде пропишем, что кто с 0,тот ход скипается
       self.status = "проигравший"
   elif self.dice == 1:
       self.status = "мапуто"
   else:  # 2+ кубика
       self.status = "нейтральный"
"""
   5. Введение результата броска игрока
"""
def brosok(self, manual: bool = False):  # функция осуществления бросков
   if manual:  # наш вводим вручную
       while True:
           print("Введите значения своих кубиков (от 1 до 6) через пробел: ")
           values = input().strip().split()  # вводим наши значения через пробел. На всякий случай делаем strip от всего лишнего
           try:  # конструкция try-except - чтобы исключить варианты, когда введено что-то не то
               nums = list(map(int, values))  # закидываем в список
               if len(nums) != self.dice:  # проверка, чтобы количество введенных нами значений совпадало с текущим колвом кубиков
                   print(f"Ошибка: должно быть ровно {self.dice} кубиков!")
                   continue
               if not all(1 <= val <= 6 for val in nums):  # проверка, что все введенные значения в диапазоне 1-6 (кубик-шестигранник)
                   print("Ошибка: значения должны быть от 1 до 6!")
                   continue
               self.hand = nums  # закидываем наш проверенный и правильный список в характеристики класса
               break
           except ValueError:  # вторая часть конструкции try-except. ValueError - проверка на неподдерживаемые значения
               print("Ошибка: вводите только числа!")
   else:  # броски остальных - неизвестны, поэтому оставляем пустыми
       self.hand = []
"""
class Perudo: 
"""
Функции про раунды:
   6. Определение роли игрока в раунде
   7. Определение количества активных игроков
   8. Установление очередности игроков
   9. Проверка наличия нашего игрока в игровом процессе
   10. Начало нового раунда (+ мб вывод текущего положения)
   11. Если (9) выполняется, то просит наши кости через (5)
   12. Ввод итогов раунда - победа/проигрыш и обновление статуса через (4) + общего кол-ва кубиков
   13. Проверка на победу во всей игре и возвращение итога, при победе
   14. Общая функция процесса игры, в которую мы кладем все предыдущее


   15. Начало игры
"""

